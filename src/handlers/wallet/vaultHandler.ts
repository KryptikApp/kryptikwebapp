import { randomBytes } from "crypto";
import * as crypt from "crypto-js";
import HDSeedLoop, { SerializedSeedLoop } from "hdseedloop";
import { IWallet } from "../../models/KryptikWallet";
import { UserDB } from "../../models/user";

import { combineShares, createShares, ShamirOptions } from "./shareHandler";

export interface VaultContents {
  // ciphertext of encrypted seedloop
  seedloopSerlializedCipher: string;
  // version: default is 0
  vaultVersion: number;
  // share of the encryption key
  localShare: string;
  // timestamps stored as...
  // number of milliseconds since the epoch
  lastUnlockTime: number;
  createdTime: number;
  // user id generated by wallet app
  uid: string;
  // if unlock correct, should read "valid"
  check: string;
}

/** Type wrapper for vault and shamir shares
 * @param vault Contents of the vault.
 * @param remoteShare1 Reserved server.
 * @param remoteShare2 Reserved for secondary device
 */
export interface VaultAndShares {
  vault: VaultContents;
  remoteShare1: string;
  remoteShare2: string;
}

export const createVault = function (
  seedloop: HDSeedLoop,
  uid: string
): VaultAndShares {
  let seedloopSerialized: SerializedSeedLoop = seedloop.serialize();
  // genrate random encryption key
  let newPassword = randomBytes(256).toString("hex");
  let seedloopString = JSON.stringify(seedloopSerialized);
  let seedloopEncrypted: string = crypt.AES.encrypt(
    seedloopString,
    newPassword
  ).toString();
  const shamirOptions: ShamirOptions = {
    shares: 3,
    threshold: 2,
  };
  // generate shares from encryption key
  let shares: Buffer[] = createShares(newPassword, shamirOptions);
  // there should be precisely three shares created
  if (shares.length != 3) {
    console.log("Incorrect sharesssss");
    throw new Error(`${shares.length} shares were created. Expected 3.`);
  }
  // create string rep.'s of secret shares
  let remoteShare1 = shares[0].toString("hex");
  let remoteShare2 = shares[1].toString("hex");
  let localShare = shares[2].toString("hex");
  let newVault: VaultContents = {
    seedloopSerlializedCipher: seedloopEncrypted,
    vaultVersion: 0,
    localShare: localShare,
    createdTime: Date.now(),
    lastUnlockTime: 0,
    uid: uid,
    check: "valid",
  };
  // string that represents vault with encrypted seedloop
  let vaultString: string = JSON.stringify(newVault);
  // key to access vault in local storage
  let vaultName: string = createVaultName(uid);
  localStorage.setItem(vaultName, vaultString);
  return {
    vault: newVault,
    remoteShare1: remoteShare1,
    remoteShare2: remoteShare2,
  };
};

/** Check if vault for a given uid exists in local storage */
export const vaultExists = function (uid: string): boolean {
  let vaultName: string = createVaultName(uid);
  let vaultString: string | null = localStorage.getItem(vaultName);
  if (vaultString == null) {
    return false;
  }
  return true;
};

export function fetchVault(vaultName: string): string | null {
  let vaultString: string | null = localStorage.getItem(vaultName);
  return vaultString;
}

/**
 * @returns Array of all vault names in local storage
 */
export function getAllVaultNames(): string[] {
  let vaults: string[] = [];
  for (let i = 0; i < localStorage.length; i++) {
    let key: string | null = localStorage.key(i);
    if (key != null && key.startsWith("wallet|")) {
      vaults.push(key);
    }
  }
  return vaults;
}

/**
 * Parses uid from vault name
 * @param vaultName Name of vault to parse
 * @returns uid of vault
 */
export function getUidFromVaultName(vaultName: string): string {
  return vaultName.split("|")[1];
}

export const unlockVault = function (
  uid: string,
  remoteShare: string,
  seedloopUpdated?: HDSeedLoop
): HDSeedLoop | null {
  let vaultName: string = createVaultName(uid);
  let vaultString: string | null = fetchVault(vaultName);
  if (vaultString == null) {
    console.warn("There is no vault to unlock with the given id.");
    return null;
  }
  let vaultRecovered: VaultContents = JSON.parse(vaultString);
  // update last unlock time
  vaultRecovered.lastUnlockTime = Date.now();
  // array of shamir secret shares
  let shareArray: string[] = [remoteShare, vaultRecovered.localShare];
  let passwordRecovered: string = combineShares(shareArray).toString();
  let seedloopDeciphered = crypt.AES.decrypt(
    vaultRecovered.seedloopSerlializedCipher,
    passwordRecovered
  ).toString(crypt.enc.Utf8);
  let seedloopSerialized: SerializedSeedLoop = JSON.parse(seedloopDeciphered);
  console.log("deserializing seedloop");
  let seedloopRecovered = HDSeedLoop.deserialize(seedloopSerialized);
  console.log("done!");
  // update vault seedloop if updated seedloop is provided
  if (seedloopUpdated) {
    let seedloopSerialized: SerializedSeedLoop = seedloopUpdated.serialize();
    // genrate random encryption key
    let seedloopString = JSON.stringify(seedloopSerialized);
    let seedloopEncrypted: string = crypt.AES.encrypt(
      seedloopString,
      passwordRecovered
    ).toString();
    vaultRecovered.seedloopSerlializedCipher = seedloopEncrypted;
    const updatedVaultToStore: string = JSON.stringify(vaultRecovered);
    localStorage.setItem(vaultName, updatedVaultToStore);
  }
  // update local storage vault
  // string that represents vault with encrypted seedloop
  let vaultStringUpdated: string = JSON.stringify(vaultRecovered);
  localStorage.setItem(vaultName, vaultStringUpdated);
  return seedloopRecovered;
};

/** Ensure vault was decoded correctly */
const isValidVaultDecode = function (vault: VaultContents): boolean {
  return vault.check == "valid";
};

/** Creates standard vault name given uid  */
export function createVaultName(uid: string) {
  return "wallet|" + uid;
}

/** Update local seedloop. */
export const updateVaultSeedloop = function (
  uid: string,
  remoteShare: string,
  wallet: IWallet
) {
  unlockVault(uid, remoteShare, wallet.seedLoop);
};

export const deleteVault = function (uid: string) {
  let vaultName = createVaultName(uid);
  console.log("removing vault with name:");
  console.log(vaultName);
  localStorage.removeItem(vaultName);
};

/**Updates vault name from email to id based */
export function updateVaultName(user: UserDB) {
  // only run if legacy vault name version with email
  if (user.email && vaultExists(user.email)) {
    const oldVaultName = createVaultName(user.email);
    const vaultContents: string | null = fetchVault(oldVaultName);
    if (!vaultContents) return;
    const newVaultName = createVaultName(user.uid);
    localStorage.setItem(newVaultName, vaultContents);
    localStorage.removeItem(oldVaultName);
  }
}
